use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Clone)]
#[repr(C)]
pub struct GameConfig {
    pub height:         u32,
    pub width:          u32,
    pub paddle_length:  u32,
    pub paddle_width:   u32,
    pub ball_radius:    u32,
    pub ball_speed:     u32,
    pub winning_score:  u32,
    pub max_ticks:      u32,
}

#[derive(Serialize, Deserialize, Clone)]
#[repr(C)]
pub struct GameState {
    pub p0_pos:     f64,
    pub p1_pos:     f64,
    pub p0_score:   u32,
    pub p1_score:   u32,
    pub ball_pos:   (f64, f64),
    pub ball_vel:   (f64, f64),
    pub tick:       u32
}

pub type TickAction = f64;
pub type InitAction = f64;

// generated by chatty
pub fn run_tick(state: &mut GameState, conf: &GameConfig, p0: TickAction, p1: TickAction) {
    // Apply player movement
    state.p0_pos += p0;
    state.p1_pos += p1;

    // Clamp paddles to field
    let half_height = conf.height as f64 / 2.0;
    let pad_half = conf.paddle_length as f64 / 2.0;
    state.p0_pos = state.p0_pos.clamp(-half_height + pad_half, half_height - pad_half);
    state.p1_pos = state.p1_pos.clamp(-half_height + pad_half, half_height - pad_half);

    // Update ball position
    state.ball_pos.0 += state.ball_vel.0;
    state.ball_pos.1 += state.ball_vel.1;

    // Wall collision
    if state.ball_pos.1 + (conf.ball_radius as f64) > half_height || state.ball_pos.1 - (conf.ball_radius as f64) < -half_height {
        state.ball_vel.1 *= -1.0;
    }

    // Paddle collision
    let pad_x = (conf.width / 2 - conf.paddle_width) as f64;
    let pad_y = conf.paddle_length as f64 / 2.0;

    if state.ball_pos.0 < -pad_x {
        // Left side
        if (state.ball_pos.1 - state.p0_pos).abs() <= pad_y {
            state.ball_vel.0 *= -1.0;
        } else {
            // Miss
            state.p1_score += 1;
            reset_ball(state, conf, false);
        }
    } else if state.ball_pos.0 > pad_x {
        // Right side
        if (state.ball_pos.1 - state.p1_pos).abs() <= pad_y {
            state.ball_vel.0 *= -1.0;
        } else {
            // Miss
            state.p0_score += 1;
            reset_ball(state, conf, true);
        }
    }
    state.tick += 1;
}

// generated by chatty
fn reset_ball(state: &mut GameState, conf: &GameConfig, left: bool) {
    state.ball_pos = (0.0, 0.0);
    let dir = if left { -1.0 } else { 1.0 };
    state.ball_vel = (dir * conf.ball_speed as f64, dir * conf.ball_speed as f64);
}
