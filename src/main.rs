use std::{rc::Rc, sync::atomic::AtomicU8};

use serde::{Serialize, Deserialize};
use serde_json::{Result, Value};


#[derive(Serialize, Deserialize)]
#[repr(C)]
struct GameConfig {
    height:         u32,
    width:          u32,
    paddle_length:  u32,
    paddle_width:   u32,
    ball_radius:    u32,
    ball_speed:     u32,
    winning_score:  u32,
    max_ticks:      u32,
}

#[derive(Serialize, Deserialize)]
#[repr(C)]
struct GameState {
    p0_pos:     f64,
    p1_pos:     f64,
    p0_score:   u32,
    p1_score:   u32,
    ball_pos:   (f64, f64),
    ball_vel:   (f64, f64),
    tick:       u32
}

type TickResponse = f64;
type InitResponse = f64;

const ENGINE_READY:   u8 = 0;
const RESPONSE_READY: u8 = 1;

const TELEMETRY_SZ: usize = 1024;

#[repr(C)]
struct Telemetry { // TODO this is for engine to communicate with bot
    msg: [u8; TELEMETRY_SZ - 1],
    avail: bool,
}

#[repr(C)]
enum ShmMsg {
    Init {
        config:     GameConfig,
        response:   InitResponse,
    },
    Tick {
        state:      GameState,
        response:   TickResponse,
    }
}

#[repr(C)]
struct Shm {
    shm: ShmMsg
    telemetry:  Telemetry,
    sync:       AtomicU8,
}

#[derive(Clone)]
struct Strategy {
    on_init: Rc<dyn Fn(&GameConfig) -> InitResponse>,
    on_tick: Rc<dyn Fn(&GameConfig, &GameState) -> TickResponse>
}

// generated by chatty
fn run_tick(state: &mut GameState, conf: &GameConfig, p0: &Strategy, p1: &Strategy) {
    // Apply player movement
    let p0_mv = (p0.on_tick)(conf, state).clamp(-1.0, 1.0);
    let p1_mv = (p1.on_tick)(conf, state).clamp(-1.0, 1.0);
    state.p0_pos += p0_mv;
    state.p1_pos += p1_mv;

    // Clamp paddles to field
    let half_height = conf.height as f64 / 2.0;
    let pad_half = conf.paddle_length as f64 / 2.0;
    state.p0_pos = state.p0_pos.clamp(-half_height + pad_half, half_height - pad_half);
    state.p1_pos = state.p1_pos.clamp(-half_height + pad_half, half_height - pad_half);

    // Update ball position
    state.ball_pos.0 += state.ball_vel.0;
    state.ball_pos.1 += state.ball_vel.1;

    // Wall collision
    if state.ball_pos.1 + (conf.ball_radius as f64) > half_height || state.ball_pos.1 - (conf.ball_radius as f64) < -half_height {
        state.ball_vel.1 *= -1.0;
    }

    // Paddle collision
    let pad_x = (conf.width / 2 - conf.paddle_width) as f64;
    let pad_y = conf.paddle_length as f64 / 2.0;

    if state.ball_pos.0 < -pad_x {
        // Left side
        if (state.ball_pos.1 - state.p0_pos).abs() <= pad_y {
            state.ball_vel.0 *= -1.0;
        } else {
            // Miss
            state.p1_score += 1;
            reset_ball(state, conf, false);
        }
    } else if state.ball_pos.0 > pad_x {
        // Right side
        if (state.ball_pos.1 - state.p1_pos).abs() <= pad_y {
            state.ball_vel.0 *= -1.0;
        } else {
            // Miss
            state.p0_score += 1;
            reset_ball(state, conf, true);
        }
    }

    state.tick += 1;
}

// generated by chatty
fn reset_ball(state: &mut GameState, conf: &GameConfig, left: bool) {
    state.ball_pos = (0.0, 0.0);
    let dir = if left { -1.0 } else { 1.0 };
    state.ball_vel = (dir * conf.ball_speed as f64, dir * conf.ball_speed as f64);
}

fn main() {
    let conf = GameConfig {
        height:         200,
        width:          400,
        paddle_length:  30,
        paddle_width:   5,
        ball_radius:    5,
        ball_speed:     5,
        winning_score:  5,
        max_ticks:      50000,
    };

    let p0 = Strategy {
        on_init: Rc::new(|_| 0.0),
        on_tick: Rc::new(|_, state| {
            if state.ball_pos.1 > state.p0_pos {
                1.0
            } else {
                -1.0
            }
        })
    };

    let p1 = Strategy {
        on_init: Rc::new(|_| 0.0),
        on_tick: Rc::new(|_, state| {
            if state.ball_pos.1 > state.p1_pos {
                1.0
            } else {
                -1.0
            }
        })
    };

    let mut state = GameState {
        p0_pos:     (p0.on_init)(&conf),
        p1_pos:     (p1.on_init)(&conf),
        p0_score:   0,
        p1_score:   0,
        ball_pos:   (0.0, 0.0),
        ball_vel:   (-(conf.ball_speed as f64), conf.ball_speed as f64),
        tick:       0
    };

    println!("{}", serde_json::to_string(&conf).expect("parse err"));
     
    while state.tick < conf.max_ticks && state.p0_score < conf.winning_score && state.p1_score < conf.winning_score {
        run_tick(&mut state, &conf, &p0, &p1);
        println!("{}", serde_json::to_string(&state).expect("parse err"));
    }
}

